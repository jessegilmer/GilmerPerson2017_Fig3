%% Created 11/23/16 by Gilmer, J. editied 12/15/16
% This is the GC generator. It needs to be fed:
%                          MFr - The MFr population generated by
%                          MFr_Generation.
%
%                          POP - The number of GCs to create.
%
%                          gc_reach - The max distance between MFrs and
%                          GCs.
%
%                          gc_mf_min - The minimum distance between MFrs and
%                          GCs.
%
%                          GC_div - The divergence, i.e. how many MFrs a GC
%                          connects with.
%
%                          GC_conv - The convergence, i.e. how many GCs a
%                          MFr connects with.
%
%   Example: [GC,MF,~] = GC_Generation(MF, 62000000, 28, 10)


function [GC,MFr,error_out] = GC_Generation(MFr,POP,gc_reach,gc_mf_min,GC_div,GC_conv)
%% Some intial information gathering.
%this will let us know if the simulation went badly.
error_out = 0;
sheererror = 0;
rng('shuffle');
%this has to do with spherepacking, this describes the number of adjacent
%spheres allowed. 5 is fine.
conn_lim = 5;
tic; 

%get MFr coordinates in one big matrix.
for j = 1:length(MFr)
    mfrx(j) = MFr(j).x;
    mfry(j) = MFr(j).y;
    mfrz(j) = MFr(j).z;
end

max_id = 0;
for i = 1:length(MFr);
    if MFr(i).id > max_id;
        max_id = MFr(i).id;
        daughter_array(i) = MFr(i).daughters;
    end
    for j = 1:length(MFr);
        % collect distances between MFrs in one big matrix.
%         distress(i,j) = sqrt((MFr(i).x - MFr(j).x)^2 + (MFr(i).y - MFr(j).y)^2 + (MFr(i).z - MFr(j).z)^2);
    end
end

runner = [];
%% Placing GCs.
gcct = 0;
while gcct < POP;
    
    %This simulation can easily not be completed, this is the threshhold
    %for how many errors it is willing to accept befor giving up.
    if sheererror > 10000;
        error_out = 1
        break;
    end
    
    %we'll protect early seeded GCs by giving them no neighbor
    %requirements.
    error_check1 = 2;
    
    dists_bin = [];
    gc_dist_bin = [];
    if gcct > 1;
        
        while size(dists_bin,2) < 4 || size(gc_dist_bin,1) > 0
            randmf = find(daughter_array == min(daughter_array));
            randmf = randmf(randi([1 length(randmf)],1,1));
%           randmf = randi([1 length(MFr)],1,1);
            while MFr(randmf).daughters > 70;
                randmf = find(daughter_array == min(daughter_array));
                randmf = randmf(randi([1 length(randmf)],1,1));
            end
            p = randi([gc_mf_min gc_reach],1,1);
            phi = 2*pi*(randi([0 1000],1,1)/1000);
            ang = 2*pi*(randi([0 1000],1,1)/1000);
            a = MFr(randmf).x + p*sin(phi)*cos(ang);
            b = MFr(randmf).y + p*sin(phi)*sin(ang);
            c = MFr(randmf).z + p*cos(phi);
            
            %look for distances to MFrs
            distressx = a - mfrx;
            distressy = b - mfry;
            distressz = c - mfrz;
            mf_dists = sqrt(distressx.^2 + distressy.^2 + distressz.^2);
            % Only take MFrs within gc_reach.
            dists_bin = find(mf_dists < gc_reach);
            
            gc_dists = sqrt(((a - runner(:,1)).^2) + ((b - runner(:,2)).^2) + ((c - runner(:,3)).^2));
            gc_dist_bin = find(gc_dists < 6);
        end
    else
        while size(dists_bin,2) < 4
            randmf = randi([1 length(MFr)],1,1);
            while MFr(randmf).daughters > 60;
                randmf = randi([1 length(MFr)],1,1);
            end
            p = randi([gc_mf_min gc_reach],1,1);
            phi = 2*pi*(randi([0 1000],1,1)/1000);
            ang = 2*pi*(randi([0 1000],1,1)/1000);
            a = MFr(randmf).x + p*sin(phi)*cos(ang);
            b = MFr(randmf).y + p*sin(phi)*sin(ang);
            c = MFr(randmf).z + p*cos(phi);
            
            %look for distances to MFrs
            distressx = a - mfrx;
            distressy = b - mfry;
            distressz = c - mfrz;
            mf_dists = sqrt(distressx.^2 + distressy.^2 + distressz.^2);
            % Only take MFrs within gc_reach.
            dists_bin = find(mf_dists < gc_reach);
        end
    end
    
    gcct = gcct + 1;
    %this reports progress and time.
    if mod(gcct,100) == 0;
        toc
        progress = [gcct POP]
        %       available_GCS = length(candidates)
        tic
    end
    
    p_choice = nchoosek(dists_bin,4);
    for i = 1:size(p_choice,1);
        p_choice_out(i) = min([MFr(p_choice(i,1)).daughters ...
            MFr(p_choice(i,2)).daughters MFr(p_choice(i,3)).daughters ...
            MFr(p_choice(i,4)).daughters]);
        p_choice_max(i) = max([MFr(p_choice(i,1)).daughters ...
            MFr(p_choice(i,2)).daughters MFr(p_choice(i,3)).daughters ...
            MFr(p_choice(i,4)).daughters]);
    end
    parent_choice = find(p_choice_out == min(p_choice_out));
  
    randchoice = randi([1 size(parent_choice,2)],1,1);
    parents = p_choice(parent_choice(randchoice),:);
    pt_counter = 1;
    error = 0;
    while p_choice_max(randchoice)> 85
        randchoice = randi([1 size(parent_choice,2)],1,1);
        parents = p_choice(parent_choice(randchoice),:);
        pt_counter = pt_counter + 1;
        if pt_counter == 100
            error = 1;
            continue
        end
    end
    
    clear parent_choice p_choice_out p_choice_max parent_choice2 choice_out p_choice
    if error == 1
        continue
    end
    for i = 1:length(parents)
        MFr(parents(i)).daughters = MFr(parents(i)).daughters + 1;
        daughterids = MFr(parents(i)).daughterid;
        daughterids = [daughterids,gcct];
        MFr(parents(i)).daughterid = daughterids;
        daughter_array(parents(i)) = MFr(parents(i)).daughters;
    end
    
    %finalize GC.
    GC(gcct).x = a;
    GC(gcct).y = b;
    GC(gcct).z = c;
    GC(gcct).parents = parents;
    runner(gcct,:) = [a b c];

    %If we made it this far, we reset the error coutner.
    sheererror = 0;
    
    clearvars -except MFr POP gc_reach gc_mf_min GC_div GC_conv GC...
        conn_lim error_out sheererror mfrx mfry mfrz....
                      max_id distress gcct runner daughter_array;
    
end